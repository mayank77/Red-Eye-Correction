
#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include <stdio.h>

__global__ 
void gaussian_blur(
    unsigned short* const       blurredChannel,                     // return value: blurred channel (either red, green, or blue)
    const unsigned short* const inputChannel,                       // red, green, or blue channel from the original image
    int                         rows, 
    int                         cols,
    const float* const          filterWeight,                       // gaussian filter weights. The weights look like a bell shape.
    int                         filterWidth                         // number of pixels in x and y directions for calculating average blurring
    )
{
    int r           =  blockIdx.y * blockDim.y + threadIdx.y;       // current row
    int c           =  blockIdx.x * blockDim.x + threadIdx.x;       // current column


    if ((r >= rows) || (c >= cols))
    {
        return;
    }

    int           half   = filterWidth / 2;
    float         blur   = 0.f;                             // will contained blurred value
    int           width  = cols - 1;
    int           height = rows - 1;

    for (int i = -half; i <= half; ++i)                 // rows
    {
        for (int j = -half; j <= half; ++j)             // columns
        {
            // Clamp filter to the image border
            int     h       = min(max(r + i, 0), height);
            int     w       = min(max(c + j, 0), width);

            // Blur is a product of current pixel value and weight of that pixel.
            // Remember that sum of all weights equals to 1, so we are averaging sum of all pixels by their weight.
            int     idx     = w + cols * h;                                         // current pixel index
            float   pixel   = static_cast<float>(inputChannel[idx]);

                    idx     = (i + half) * filterWidth + j + half;
            float   weight  = filterWeight[idx];

            blur += pixel * weight;
        }
    }

    blurredChannel[c + r * cols] = static_cast<unsigned short>(blur);
}





void createFilter(float *gKernel,double sigma,int radius)
{

    double r, s = 2.0 * sigma * sigma;

    // sum is for normalization
    double sum = 0.0;

    // generate 9*9 kernel
    int m=0;
    for (int x = -radius; x <= radius; x++)
    {
        for(int y = -radius; y <= radius; y++)
        {
            r = std::sqrtf(x*x + y*y);
            gKernel[m] = (exp(-(r*r)/s))/(3.14 * s);
            sum += gKernel[m];
            m++;
        }
    }
 m=0;
    // normalize the Kernel
    for(int i = 0; i < (radius*2 +1); ++i)
        for(int j = 0; j < (radius*2 +1); ++j)
            gKernel[m++] /= sum;


}


int main()
{

    cudaError_t cudaStatus;
    const int size =81;
    float gKernel[size];

    float *dev_p=0;
    cudaStatus =  cudaMalloc((void**)&dev_p, size * sizeof(float));
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMemcpy failed!");
    }
    createFilter(gKernel,20.0,4);

    cudaStatus = cudaMemcpy(dev_p, gKernel, size* sizeof(float), cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMemcpy failed!");
    }

    /*  i read image Buffere in unsigned short that code is not added here ,becouse it is large , and copy image data of buffere from host to device*/

    /* So, suppose i have unsigned short *d_img which contain image data */
	unsigned short *d_img,*d_blur_img;
    cudaMalloc( (void**) &d_img, size* sizeof(unsigned short));
    cudaMalloc( (void**) &d_blur_img, size* sizeof(unsigned short));

    static const int BLOCK_WIDTH = 32;
    int image_width=1580.0,image_height=1050.0;

    int x = static_cast<int>(ceilf(static_cast<float>(image_width) / BLOCK_WIDTH));
    int y = static_cast<int>(ceilf(static_cast<float>((image_height) ) / BLOCK_WIDTH));

    const dim3 grid (x, y, 1);                              // number of blocks
    const dim3 block(BLOCK_WIDTH, BLOCK_WIDTH, 1);  

    gaussian_blur<<<grid,block>>>(d_blur_img,d_img,1050.0,1580.0,dev_p,9.0);

    cudaDeviceSynchronize();

    /* after bluring image i will copied buffer from Device to Host and free gpu memory */
    cudaFree(d_img);
    cudaFree(d_blur_img);
    cudaFree(dev_p);


return 0;
}